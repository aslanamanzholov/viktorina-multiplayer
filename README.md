#  API
POST `/api/register` На этот адрес высылается форма со следующими полями: email - электронная почта пользователя, password - пароль пользователя в открытом виде, nickname - никнейм пользователя на сайте. На этот запрос могут быть следующие варианты ответа: 302 Found - вместе с этим ответом придёт HTTPOnly Cookie с токеном доступа и заголовок Location со ссылкой, по которой нужно пройти (ссылка будет на GET /profile), второй вариант ответа - 500 InternalServerError, в теле ответа будет лежать сообщение, которое нужно вывести на экран (пока можно через alert)

POST `/api/auth` На этот адрес высылается форма авторизации пользователя с полями: email - электронная почта пользователя (никнейм лучше не использовать при авторизации, я бы его вообще бы лучше сделал не уникальным, как, например, в DOTA2, чтобы не городить лишних проверок) и второе поле - password - пароль пользователя в открытом виде. Обязательное условие обработки запроса - наличие заголовка Referer = 'URL'. URL при этом равен той странице - которую пользователь хотел получить перед прохождением авторизации. По умолчанию URL='/'. Варианты ответа сервера 302 Found - вместе с этим ответом придёт HTTPOnly Cookie с токеном доступа и заголовок Location со ссылкой на URL из заголовка Referer, по которой нужно пройти, второй вариант ответа - 500 InternalServerError, в теле ответа будет лежать сообщение, которое нужно вывести на экран (пока можно через alert)

 GET `/api/profile` На этот запрос возможны следующие ответы: 401 Unathorized - в этом случае пользователя необходимо автоматически направить на форму авторихации и в Referer записать /profile, второй вариант - 200 OK с заголовком Content-type=application/json, в теле такого запроса будет JSON вида:

`{
  "nickname": "BestUser",
  "email": "user@mail.ru",
  "won": "100500",
  "lost": "0",
  "play_time": "5678906",
  "avatar_path": "static/img/my_avatar.jpeg"
}`

ВАЖНО: аватар с ответом на этот запрос не приходит, он запрашивается отдельно (см. ниже)

 PATCH /api/profile Ha этот адрес высылается форма, закодированная способом multipart/form-data, с полями email - электронная почта пользователя, nickname - никнейм пользователя на сайте, avatar - файл-картинка с аватаром пользователя. 200 OK и 500 InternalServerError, в обоих вариантах в теле ответа будет сообщение, которое нужно показать пользователю

 GET /api/avatar В ответ на этот запрос должна придти аватарка пользователя с кодом 200 OK и заголовком Content-type=image/...

 GET /api/records?page=<int> В ответ на этот запрос должен придти ответ с кодом 200 OK и заголовком Content-type=application/json, в теле ответа должен лежать JSON вида:

{
  "pages_total": "100500",
  "page": "2",
  "data": [
      {
        "nickname": "User1",
        "won": "100500",
        "lost": "0",
        "play_time": "5678906"
      },
      {
        "nickname": "User2",
        "won": "100499",
        "lost": "1",
        "play_time": "5678906"
      },
      {
        "nickname": "User3",
        "won": "100498",
        "lost": "2",
        "play_time": "5678906"
      }
    ]
}
ВАЖНО: длину массива не посылаю, там через forEach можно проитерироваться, массив придёт уже отсортированным в нужном порядке

ВАЖНО
В API указаны валидные ответы, но из-за багов, неполадок на сервере, в сети или ещё где-нибудь могут придти и невалидные. Их тоже надо обрабатывать, на этом этапе достаточно выдавать alert с кодом и расшифровкой такого ответа
В дальнейшем для сообщений пользователю вместо алертов будет логично ввести систему нотификаций, но она должна работать на Web сокетах, насколько я это сейчас понимаю